import{_ as n,o as a,c as s,f as e}from"./app-eb665f75.js";const i={},t=e(`<h1 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h1><p>是⼀种可以提升查询效率的结构，⽬的就是为了提⾼查询的效率</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>创建索引：<span class="token keyword">create</span> <span class="token keyword">index</span> 索引名 <span class="token keyword">on</span> 表名<span class="token punctuation">(</span>字段名<span class="token punctuation">)</span> <span class="token punctuation">;</span> （id性能最高） 
创建表时候也可创建索引
查看索引是否⽣效：<span class="token keyword">explain</span> 查询语句 <span class="token keyword">where</span> 索引字段<span class="token operator">=</span>值<span class="token punctuation">;</span> 
删除索引：<span class="token keyword">alter</span> <span class="token keyword">table</span> 表名 <span class="token keyword">drop</span> <span class="token keyword">index</span> 索引名<span class="token punctuation">;</span> 
查看表上的索引：<span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> 表名<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>索引的分类：<br><strong>1.聚簇索引 也就是我们常用的id</strong><br><strong>2.普通索引</strong><br><strong>3.唯⼀索引(UNIQUE)</strong><br><strong>4.联合索引</strong><br><a name="dInYy"></a></p><h2 id="一、索引底层" tabindex="-1"><a class="header-anchor" href="#一、索引底层" aria-hidden="true">#</a> 一、索引底层</h2><p><strong>B-Tree</strong><br> B树的每一个结点都存储了key(索引值) 和 value(对应数据)<br>不利于范围查找(区间查找)，如果要找 0~100的索引值，那么B树需要回旋查询，效率低<br><img src="https://steven-kz.github.io/BlogImgs/imgaes/20231011164449.png" alt="img.png" loading="lazy"><br><strong>B+Tree</strong><br>底层有一个单项链表(从小排序的)，也就是叶子节点，存储了索引值和数据地址。<br>非叶子节点只存放索引值。<br>优点：查询速度快，当有排序的时候不需要进行回旋查找<br><img src="https://steven-kz.github.io/BlogImgs/imgaes/20231011160437.png" alt="image.png" loading="lazy"><br><a name="Fumvp"></a></p><h2 id="二、索引失效原理" tabindex="-1"><a class="header-anchor" href="#二、索引失效原理" aria-hidden="true">#</a> 二、索引失效原理</h2><div class="hint-container warning"><p class="hint-container-title">索引失效分类</p><p>不符合最左匹配规则的原理<br>使用函数<br>%Like<br>使用Or导致索引失效<br>in使用不当<br>order By</p></div><figure><img src="https://steven-kz.github.io/BlogImgs/imgaes/20231011160500.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol><li>主要是联合索引 举几个例子 ，定义一个联合索引为 (a,b) ，联合索引查找的原理就是最左匹配原则，当a相等时，b的值也是有序的，这个时候根据二分法也是可以找到b对应的值，但是如果只查找b值的话，那就不存在a，那么b就是无序的，是没办法使用索引的，只能进行全表扫描，这种情况针对最左匹配原则</li><li>还有一个经典案例就是 当查询的第一个a值使用大于小于号的时候，a得值就是不确定的，那么b的值也就是无序的，无法使用索引，这里是不能使用&lt;&gt;号的。<br><a name="TWUBg"></a></li></ol><h2 id="三、innodb存储原理" tabindex="-1"><a class="header-anchor" href="#三、innodb存储原理" aria-hidden="true">#</a> 三、InnoDB存储原理</h2><div class="hint-container tip"><p class="hint-container-title">说明</p><p>1.聚簇索引(主键索引) 非叶子节点存储的key就是主键值，页子节点存储的key是主键值,value就是这一行的数据。<br>2.而其他索引的非叶子节点存的索引值是对应的值，叶子节点的value存储的是主键key，在根据主键key来一次聚簇索引拿到数据，所以这就是不推荐使用select * 的原因。<br></p></div><figure><img src="https://steven-kz.github.io/BlogImgs/imgaes/20231011160521.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>`,13),r=[t];function o(l,p){return a(),s("div",null,r)}const c=n(i,[["render",o],["__file","MysqlIndex.html.vue"]]);export{c as default};
