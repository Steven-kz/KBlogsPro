const t=JSON.parse('{"key":"v-6307bbd9","path":"/interview/java/JVM_GC.html","title":"JVM_GC","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2022-01-04T00:00:00.000Z","lastUpdated":true,"contributors":true,"description":"JVM_GC 一、JVM运行时数据区域 JDK1.7：程序计数器、虚拟机栈、本地⽅法栈、堆、⽅法区JDK1.8：程序计数器、虚拟机栈、本地⽅法栈、堆、元空间程序计数器：记录每个线程的执⾏的字节⾏数。线程私有 虚拟机栈：方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出，就是记录运行时需要的内存空间，方法参数。线程私有本地方法栈： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务，其他都与虚拟机栈一致。线程私有堆：记录⼤部分对象存储所需要的空间，最复杂的内存区域，内部分为：新⽣代（伊甸区+幸存者区 1+幸存者区2）和⽼年代 方法区（1.7）：存储类的信息（编译字节、静态区（静态变量、⽅法）、⽅法）和常量池 元空间（1.8）：没有在JVM内存区，⽽是直接使⽤电脑的内存区，存储类的信息（编译字节、静态区 （静态变量、⽅法）、⽅法）和常量池 直接内存：没有在JVM内存区，⽽是直接使⽤电脑的内存区，NIO有个Buffer,有⼀个叫直接内存 栈管运⾏，堆管存储。则虚拟机栈负责运⾏代码，⽽虚拟机堆负责存储数据","head":[["meta",{"property":"og:url","content":"https://steven-kz.github.io/KBlogsPro/KBlogsPro/interview/java/JVM_GC.html"}],["meta",{"property":"og:site_name","content":"Flowers"}],["meta",{"property":"og:title","content":"JVM_GC"}],["meta",{"property":"og:description","content":"JVM_GC 一、JVM运行时数据区域 JDK1.7：程序计数器、虚拟机栈、本地⽅法栈、堆、⽅法区JDK1.8：程序计数器、虚拟机栈、本地⽅法栈、堆、元空间程序计数器：记录每个线程的执⾏的字节⾏数。线程私有 虚拟机栈：方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出，就是记录运行时需要的内存空间，方法参数。线程私有本地方法栈： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务，其他都与虚拟机栈一致。线程私有堆：记录⼤部分对象存储所需要的空间，最复杂的内存区域，内部分为：新⽣代（伊甸区+幸存者区 1+幸存者区2）和⽼年代 方法区（1.7）：存储类的信息（编译字节、静态区（静态变量、⽅法）、⽅法）和常量池 元空间（1.8）：没有在JVM内存区，⽽是直接使⽤电脑的内存区，存储类的信息（编译字节、静态区 （静态变量、⽅法）、⽅法）和常量池 直接内存：没有在JVM内存区，⽽是直接使⽤电脑的内存区，NIO有个Buffer,有⼀个叫直接内存 栈管运⾏，堆管存储。则虚拟机栈负责运⾏代码，⽽虚拟机堆负责存储数据"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-11T09:54:31.000Z"}],["meta",{"property":"article:author","content":"Kou"}],["meta",{"property":"article:published_time","content":"2022-01-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-11T09:54:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM_GC\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-01-04T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-11T09:54:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kou\\",\\"url\\":\\"https://steven-kz.github.io/KBlogsPro/\\"}]}"]]},"headers":[{"level":3,"title":"讲下gc","slug":"讲下gc","link":"#讲下gc","children":[]},{"level":3,"title":"5、完整GC回收流程 从创建到回收","slug":"_5、完整gc回收流程-从创建到回收","link":"#_5、完整gc回收流程-从创建到回收","children":[]}],"git":{"createdTime":1697014260000,"updatedTime":1697018071000,"contributors":[{"name":"kou","email":"knightbreeze@163.com","commits":2}]},"readingTime":{"minutes":4.18,"words":1253},"filePathRelative":"interview/java/JVM_GC.md","localizedDate":"2022年1月4日","excerpt":"<h1> JVM_GC</h1>\\n<h1> 一、JVM运行时数据区域</h1>\\n<p>JDK1.7：程序计数器、虚拟机栈、本地⽅法栈、堆、⽅法区<br>JDK1.8：程序计数器、虚拟机栈、本地⽅法栈、堆、元空间<img src=\\"https://steven-kz.github.io/BlogImgs/imgaes/image-20231011164721108.png\\" alt=\\"image.png\\" loading=\\"lazy\\"><br><strong>程序计数器</strong>：记录每个线程的执⾏的字节⾏数。线程私有 <br><strong>虚拟机栈</strong>：方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出，就是记录运行时需要的内存空间，方法参数。线程私有<br><strong>本地方法栈</strong>： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务，其他都与虚拟机栈一致。线程私有<br><strong>堆</strong>：记录⼤部分对象存储所需要的空间，最复杂的内存区域，内部分为：新⽣代（伊甸区+幸存者区 <br>1+幸存者区2）和⽼年代 <br><strong>方法区（1.7）</strong>：存储类的信息（编译字节、静态区（静态变量、⽅法）、⽅法）和常量池 <br><strong>元空间（1.8）</strong>：没有在JVM内存区，⽽是直接使⽤电脑的内存区，存储类的信息（编译字节、静态区 （静态变量、⽅法）、⽅法）和常量池 <br>直接内存：没有在JVM内存区，⽽是直接使⽤电脑的内存区，NIO有个Buffer,有⼀个叫直接内存 <br>栈管运⾏，堆管存储。则虚拟机栈负责运⾏代码，⽽虚拟机堆负责存储数据</p>","autoDesc":true}');export{t as data};
