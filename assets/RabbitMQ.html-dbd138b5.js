const t=JSON.parse('{"key":"v-6c56f9d5","path":"/interview/java/RabbitMQ.html","title":"RabbitMQ","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","description":"RabbitMQ 一、消息丢失 1.1 生产者消息丢失 分为两种 1.1 事务机制可以开启事务，就是⽣产者发送数据之前开启 RabbitMQ 事务 channel.txSelect ，然后发送消息，如果说这个消息没有成功被 RabbitMQ 接收到，那么⽣产者会收到异常报错，然后就可以回滚事务 channel.txRollback ，回滚之后就重新发送消息，如果收到了消息，那么可以提交事务 channel.txCommit 但是这种方式的效率是比较低的。1.2 confirm机制 还有一种是RabbitMQ的confirm 机制，就是在生产者开启 confirm 模式，每个消息都会分配⼀个唯⼀的 id，如果说这个消息成功写⼊RabbitMQ 中，RabbitMQ 会给⽣产者回传⼀个 ack 消息，告诉mq接收到了。如果 RabbitMQ 没能处理这个消息，就会调用⼀个 nack 接⼝，就是这个消息他接收失败了，然后⽣产者继续发送消息。⽽且可以结合这个机制⾃⼰在内存⾥维护每个消息 id 的状态，如果超过⼀定时间还没接收到这个消息的回调，那么可以重发。回调的机制，推荐采⽤这种","head":[["meta",{"property":"og:url","content":"https://steven-kz.github.io/KBlogsPro/KBlogsPro/interview/java/RabbitMQ.html"}],["meta",{"property":"og:site_name","content":"Flowers"}],["meta",{"property":"og:title","content":"RabbitMQ"}],["meta",{"property":"og:description","content":"RabbitMQ 一、消息丢失 1.1 生产者消息丢失 分为两种 1.1 事务机制可以开启事务，就是⽣产者发送数据之前开启 RabbitMQ 事务 channel.txSelect ，然后发送消息，如果说这个消息没有成功被 RabbitMQ 接收到，那么⽣产者会收到异常报错，然后就可以回滚事务 channel.txRollback ，回滚之后就重新发送消息，如果收到了消息，那么可以提交事务 channel.txCommit 但是这种方式的效率是比较低的。1.2 confirm机制 还有一种是RabbitMQ的confirm 机制，就是在生产者开启 confirm 模式，每个消息都会分配⼀个唯⼀的 id，如果说这个消息成功写⼊RabbitMQ 中，RabbitMQ 会给⽣产者回传⼀个 ack 消息，告诉mq接收到了。如果 RabbitMQ 没能处理这个消息，就会调用⼀个 nack 接⼝，就是这个消息他接收失败了，然后⽣产者继续发送消息。⽽且可以结合这个机制⾃⼰在内存⾥维护每个消息 id 的状态，如果超过⼀定时间还没接收到这个消息的回调，那么可以重发。回调的机制，推荐采⽤这种"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-12T08:02:42.000Z"}],["meta",{"property":"article:author","content":"Kou"}],["meta",{"property":"article:modified_time","content":"2023-10-12T08:02:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RabbitMQ\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-10-12T08:02:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kou\\",\\"url\\":\\"https://steven-kz.github.io/KBlogsPro/\\"}]}"]]},"headers":[{"level":2,"title":"1.1 生产者消息丢失","slug":"_1-1-生产者消息丢失","link":"#_1-1-生产者消息丢失","children":[]},{"level":2,"title":"1.2 RabbitMQ服务器端","slug":"_1-2-rabbitmq服务器端","link":"#_1-2-rabbitmq服务器端","children":[]},{"level":2,"title":"1.3 消费端","slug":"_1-3-消费端","link":"#_1-3-消费端","children":[]}],"git":{"createdTime":1697020386000,"updatedTime":1697097762000,"contributors":[{"name":"kou","email":"knightbreeze@163.com","commits":2}]},"readingTime":{"minutes":2.17,"words":651},"filePathRelative":"interview/java/RabbitMQ.md","localizedDate":"2023年10月11日","excerpt":"<h1> RabbitMQ</h1>\\n<h1> 一、消息丢失</h1>\\n<h2> 1.1 生产者消息丢失</h2>\\n<p>分为两种</p>\\n<p><strong>1.1 事务机制</strong><br>可以开启事务，就是⽣产者发送数据之前开启 RabbitMQ 事务 channel.txSelect ，然后发送消息，如果说这个消息没有成功被 RabbitMQ 接收到，那么⽣产者会收到异常报错，然后就可以回滚事务 channel.txRollback ，回滚之后就重新发送消息，如果收到了消息，那么可以提交事务  channel.txCommit  但是这种方式的效率是比较低的。<br><strong>1.2 confirm机制</strong><br> 还有一种是RabbitMQ的confirm 机制，就是在生产者开启 confirm 模式，每个消息都会分配⼀个唯⼀的 id，如果说这个消息成功写⼊RabbitMQ 中，RabbitMQ 会给⽣产者回传⼀个 ack 消息，告诉mq接收到了。如果 RabbitMQ 没能处理这个消息，就会调用⼀个 nack 接⼝，就是这个消息他接收失败了，然后⽣产者继续发送消息。⽽且可以结合这个机制⾃⼰在内存⾥维护每个消息 id 的状态，如果超过⼀定时间还没接收到这个消息的回调，那么可以重发。<strong>回调的机制，推荐采⽤这种</strong></p>","autoDesc":true}');export{t as data};
