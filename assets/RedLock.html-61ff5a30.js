const e=JSON.parse('{"key":"v-233fac43","path":"/interview/java/RedLock.html","title":"分布式锁","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","description":"分布式锁 执行流程 因为是集群，普遍的锁是无法解决安全问题的，所以用来Redisson的RedLock锁，就是当有两个客户同时购买一个商品的时候，如果不使用分布式锁，就会线程不安全，可能导致出现超卖的现象，然后在那个判断库存上加锁，就是为了防止超卖的，当第一个请求进来的时候，会加锁，使用getLock加锁，锁的是一个key值，这个一般就是商品的id值，当下一个请求进来的时候，就会进不来，直到当前的锁被释放掉，才能重新加锁。 redisson 看门狗逻辑 1、假如我的业务操作比有效时间长，我的业务代码还没执行完就自动给我解锁了，不就完蛋了吗？ 给锁续期。在Redisson框架实现分布式锁的思路，就使用watchDog机制实现锁的续期。","head":[["meta",{"property":"og:url","content":"https://steven-kz.github.io/KBlogsPro/KBlogsPro/interview/java/RedLock.html"}],["meta",{"property":"og:site_name","content":"Flowers"}],["meta",{"property":"og:title","content":"分布式锁"}],["meta",{"property":"og:description","content":"分布式锁 执行流程 因为是集群，普遍的锁是无法解决安全问题的，所以用来Redisson的RedLock锁，就是当有两个客户同时购买一个商品的时候，如果不使用分布式锁，就会线程不安全，可能导致出现超卖的现象，然后在那个判断库存上加锁，就是为了防止超卖的，当第一个请求进来的时候，会加锁，使用getLock加锁，锁的是一个key值，这个一般就是商品的id值，当下一个请求进来的时候，就会进不来，直到当前的锁被释放掉，才能重新加锁。 redisson 看门狗逻辑 1、假如我的业务操作比有效时间长，我的业务代码还没执行完就自动给我解锁了，不就完蛋了吗？ 给锁续期。在Redisson框架实现分布式锁的思路，就使用watchDog机制实现锁的续期。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-14T07:24:27.000Z"}],["meta",{"property":"article:author","content":"Kou"}],["meta",{"property":"article:modified_time","content":"2023-10-14T07:24:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分布式锁\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-10-14T07:24:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kou\\",\\"url\\":\\"https://steven-kz.github.io/KBlogsPro/\\"}]}"]]},"headers":[{"level":3,"title":"执行流程","slug":"执行流程","link":"#执行流程","children":[]},{"level":3,"title":"redisson 看门狗逻辑","slug":"redisson-看门狗逻辑","link":"#redisson-看门狗逻辑","children":[]},{"level":3,"title":"Redis和Zookeeper实现分布式锁的区别","slug":"redis和zookeeper实现分布式锁的区别","link":"#redis和zookeeper实现分布式锁的区别","children":[]}],"git":{"createdTime":1697019047000,"updatedTime":1697268267000,"contributors":[{"name":"kou","email":"knightbreeze@163.com","commits":3}]},"readingTime":{"minutes":5.58,"words":1674},"filePathRelative":"interview/java/RedLock.md","localizedDate":"2023年10月11日","excerpt":"<h1> 分布式锁</h1>\\n<h3> 执行流程</h3>\\n<p>因为是集群，普遍的锁是无法解决安全问题的，所以用来Redisson的RedLock锁，就是当有两个客户同时购买一个商品的时候，如果不使用分布式锁，就会线程不安全，可能导致出现超卖的现象，然后在那个判断库存上加锁，就是为了防止超卖的，当第一个请求进来的时候，会加锁，使用getLock加锁，锁的是一个key值，这个一般就是商品的id值，当下一个请求进来的时候，就会进不来，直到当前的锁被释放掉，才能重新加锁。</p>\\n<h3> redisson 看门狗逻辑</h3>\\n<p><strong>1、假如我的业务操作比有效时间长，我的业务代码</strong>还没执行完就自动给我解锁了，不就完蛋了吗？<br>\\n给锁续期。在Redisson框架实现分布式锁的思路，就使用watchDog机制实现锁的续期。</p>","autoDesc":true}');export{e as data};
